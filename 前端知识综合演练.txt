                                                                                             第一个月


cellpadding 相当于 padding 单元格的内边距 
 cellspacing 相当于 margin 单元格的外边距 
 thead 表头 
 th 单元格 默认居中、加粗 
 tbody 表内容 
 tfoot 底部 
 
  tr 行 
 td 列 （单元格） 
 
  colspan 跨列 (横向合并) 
 rowspan 跨行 (竖向合并) 可输入的内容 
window.onload = function () {
document.documentElement.style.fontSize = document.documentElement.clientWidth/ 640 * 100 + 'px';
window.onresize = function () {
document.documentElement.style.fontSize = document.documentElement.clientWidth/ 640 * 100 + 'px';
}
}
  input 输入框  
 type 
 text 文本框 例如：用户名、地址 
 password 密码框 
 radio 单选项 （html5的标准中，属性必须要加值） 
 html5中 checked 
 html4- checked="checked" 
 checkbox 复选项（多选框） 
 file 上传 
 button 普通的按钮  
 需要验证（通过后面的js来验证） 
 submit 提交按钮  
 不需要验证就提交的 
 用在搜索 
 reset 重置按钮 
 
  属性： 
 disabled 禁止 
 checked 已选 
 value 
 form  
 action 提交的地址（要提交到哪里去） 
 method 提交方式 
 get 明文发送 
 post 加密发送 



     css选择器：
		标签选择器 （用哪个标签）
		类选择器
			简称		class
			HTML  class="xxx"
			CSS   .xxx
				在同一页面中，class可多次重复使用
		ID选择器 
			简称: id
			html   id="xxx"
			css   #xxx
			ID是唯一的
				在同一个页面中，相同名称的ID，只能出现一次。

		      	后代选择器  谁谁谁 空格 谁谁谁
				注：只要是某个元素的子集，那么这些元素都会被选中
			群组选择器 （一次选择一组元素）
				使用 , 隔开  表示 谁 和 谁
			通配符  (*表示 所有)
				*  

			ID和class区别：
				ID  身份证号、手机号
				class   人名字
	选择器优先级：
		行间（行内）样式 > ID > class > 标签选择器 > *
		在同等的优先级下，后面覆盖前面的





	                                         定位：
				position: ;
					relative - 相对定位 
						在原有的位置基础上保持不变
						偏移值（可选）：
							x: left/right
							y: top/bottom;
					absolute - 绝对定位 
						绝对定位，必须设定偏移值
							x，y必须设置
						不保留元素位置
						绝对定位需要参考元素(根据哪个元素定位的）：
							参考有定位的父级，如果父级们都没有定位，那么根据可视区定位
					fixed - 固定定位
						只参考浏览器
				特点：
					提升层级 （普通层 < 浮动层 < 定位层）
					绝对定位可以适应内容的尺寸




     行内元素默认没有高度
			如何让行内元素有高度? 需要使用 display:inline-block;

			继承（只能继承文字相关的、字体大小、字体、行高、颜色）
			如果自己没有的话，从父级去找，如果父级没有，继续往上找。

			inherited from  xxx
				继承过来的（右键-检查-向下拉，找到inherited from）
			a标签不集成父级的字体颜色

			行内元素（inline或inline-block)代码换行会产生空格，
				解决：某个元素中的行内标签少（可以数的过来3~5），直接把代码换上去掉。
				如果多的话，
					1 父级的字体大小设定为0(子元素会继承字体大小)
					2 重新设置子元素的字体大小

			1个中文文字 = 2个英文文字大小

			text-align  控制文字方向的
				left center right
				由于text-align是控制文字的，如果文字动了，盒子跟着盒子一起动。
				inline和inline-block元素受到text-align控制
表格里面单元格有对齐方式
			align 水平对齐   left  center  right
			valign 垂直对齐  top  middle bottom
			label标签  有一个 for的属性，for可以查找input的id
				（点击文字的时候，相应的input就会被选中





sublime 编辑器：
		竖向选择： 
			alt + 左键向下拉
			（按住ctrl + 左键点击，也可以多项选择）
		选择文字：
			选择单个文字，按住shift + 左右箭头
			按住 alt + shift + 左右箭头  选择一个单词

		ctrl + 左右箭头  调到当前行的开始活结束




	什么时候清浮动
			子元素浮动了，父级必须清浮动
			除非：
				父级有高度（可以确定高度的情况下）
				如果父级恰好有浮动，那可以不清浮动
					注：不要去刻意的去给父级添加浮动
			否则：
				.clearfix





什么时候清浮动？
		1 子元素浮动，父级必须清浮动。
			清浮动：
			目的：为了适应浮动元素的高度。
		1 如果有高度（高度可以固定），直接给高度。
		2 没有高度，用 overflow: hidden; 
			问题：如果子元素比父级小，超出的部分会被裁掉（隐藏）
		3 万能  .clearfix (约定俗成的名字)
				(之前谁加overflow，就给这个元素加一个clearfix)





盒模型(有宽度的基础上)：
		元素本身的尺寸（宽高） + padding + border + margin
	没有宽度的盒子如何计算宽度？
		没有宽度的盒子，盒模型不变。
		没有宽度的盒子默认父级的宽度 ，如果添加了margin、padding、border这些属性的时候，盒子保持原有的尺寸不变。
		盒子本身的宽度变小了
	
		元素本身的宽高 = 父级的尺寸 - padding - border - margin

		600 - 0 - 0 - -100




margin 能用下 不用上  能用右 不用左


a: hover 只改变需要变化的样式 



	overflow:  溢出隐藏;
			超出元素指定的宽高的时候，会把超出的裁减掉。
			如果没有指定高度，适应内容的高度。（浮动）



什么时候用背景？什么时候用图片？
		不需要经常更换的（或者说压根就不会换的） 用 背景图
		经常更换（频率很高） 用 图片




1 结构 （HTML的布局划分 - 先上下后左右）
			2 样式
			1 去除默认样式  (真正影响布局的，只有边距)
			2 添加所需要的样式
				1 从外测开始，定义好 大盒子的宽高（高度一般都是自适应<靠内容撑开的>的）
			
			文字垂直居中：
				高度是固定的，让行高和高度相等就可以
				原理：由于浏览器会把文字放到行高的中间，行高又和高度相等，所以 文字是垂直居中的




	margin的问题：
		1 子元素的 上边距  会带着父级一起动
		解决：可以用父级的padding-top替代




图片下产生的莫名间距：
		1 display:block;
		2 vertical-align: top; -推荐
		top  middle  bottom 都可以




text-align 可以控制 inline、inline-block元素




                                                                                                       第二个月


<!DOCTYPE html><!-- 声明文档类型-->
<html><!--根元素 所有的标签都在当中-->
	<head>  <!--不需要直接展示给用户的内容-->
		<meta charset="UTF-8"><!--声明编码格式 utf-8代表的是中文编码-->
		<title>html5新增的语义化标签</title> <!--标题-->
		<style>
			/*color:red;*/
		</style>
		<link rel="stylesheet" type="text/css" href=""/>
		
	</head>
	<body><!--页面主体；所有给用户展示的内容-->
		html5:
		 H5的新特征
		1、便捷的标签书写
			1、声明文档类型，2、声明编码格式
			语义化标签：
			一、块级化标签替换的是div
				本质上依然是div只不过变的有含义了；
			1、<header></header> 代表整个页面的标题头部，或者某一部分的标题或头部
			2、<nav></nav>页面中的导航
			3、	<article>  文章
					<section></section>段落
				</article>
			4、<aside></aside> 右边栏，和<article></article>中的内容相关；
			5、<footer></footer> 页面尾部
			6、<hgroup></hgroup>标签用于对网页或区段（section）的标题进行组合。 
			二、行内语义化标签
			<mark></mark>  标记等同于<span></span>
			<time></time>  时间
			三、具有特殊功能的标签
			<meter value="50" min="0" max="100"></meter>
			value代表的是当前值
			进度条表示的min最小值，max最大值
			<progress value="50" min="0" max="100"></progress>
		2、强大的绘图、动画
		<canvas id="" width="" height=""></canvas>
		3、多媒体的直接支持
		音频标签：
		1. 支持格式: wav、mp3、ogg
		语法：
		<audio src=""></audio>
		controls  播放控件（控制播放暂停进度条）
		autoplay  自动播放
		loop       循环播放
		preload：auto：下载视频
				metadata：原数据，视频信息，但是视频没有被加载
				none:不缓冲，节省流量，但很卡
		src  url   规定音频文件的 URL。
		视频标签：
		1. 支持格式: Ogv、MPEG4、WebM、mp4
		语法：
		<video src=""></video>
		poster   设置视频播放的首屏图片
		width/height 设置播放窗口的宽高
		src和href的区别：src引入 href是引用；
		视频标签
		4、表单的全新功能
		5、本地存储
		6、地理定位的API.....
		一、标签：
		新增的标签：
		</body>
	</html>
		<form action="" method="post">
			inpu
			<!--<input type="submit" value=""/>-->
		</form>
		 action   提交方法的路径；
		 method   post  秘文提交，没有大小限制；
		 		  get   明文提交，有大小限制；
		 ----
		 表单元素：
		<input type="text" />  文本输入框
		密码框：<input type="password" />
		上传按钮：<input type="file" />
		单选框：单选性别功能：
		<label for="id1">男:</label>
		<input id="id1" name="xingbie"  type="radio" />
		<label for="id2">女:</label>
		<input id="id2" name="xingbie"  type="radio" />
		复选框：
		<label for="id3">A:</label>
		<input id="id3" name="fuxuan" checked type="checkbox" />
		checked是会让当前复选框默认选取；
		普通按钮
		<input type="button" name="" id="" value="按钮1" />
		图片按钮
		<input class="IMG" src="img/4.jpg" type="image" />
		提交按钮
		<input type="submit" value="提交"/>
		重置按钮：只会重置同一表单中的内容
		<input type="reset" name="" id="" value="重置" />
		<!--<input type="submit" name="" id="" value="提交" />-->
		隐藏域：
		<input type="hidden" value="123" />
		下拉选择框：
		<select name="">
			<option value="">111</option>
			<option value="">111</option>
			<option value="">111</option>
		</select>
		文本域：
		<textarea name="" rows="" cols=""></textarea>
		 
		 新增表单元素：
		 1、email
		 功能:输入email地址的文本框
		 语法: <input type="email" />
		 特点：1、验证是否输入@，2、验证@后边有没有内容；
		 	   3、Phone 遇到这类文本框，会在键盘中添加@和.符号。
		 2、search
		 功能：输入搜索关键字操作的文本框
		 语法：<input type="search" />
		 特点：开始输入内容后，文本框的后边会出现一个叉号，这个叉号
		 可以清空输入内容。
		 3、url
		 功能：输入一个web站点地址的文本框
		 语法：<input type="url" />
		 特点：会验证你是否输入了一个完整的站点地址；
		 4、tel
		 功能：输入电话号码的文本框
		 语法：<input type="tel" />
		 特点：PC端看不到任何效果，但是移动设备浏览的时候会直接弹出
		 输入数字的键盘
		 五、color
		功能：一个选取颜色的框（拾色器）
		特点：一个选取颜色的色板，可以通过，截取，十六进制，rgb。。。颜色模式进行选择；
		语法<input type="color" />
		六、number
		功能：一个只能输入数字的文本框；
		特点：只允许输入数字，并且在输入数字后会出现一个可以调整，输入数字大小的按钮
		语法：<input step="10" min="" max="" type="number" />
			步长：step；
			允许输入的最小值：min
			允许输入的最大值：max
		七、range
		功能：用滑块表示数字
		特点：类似于number
		语法：<input step="10" min="" max=""  type="range" />
			步长：step；
			最小值：min
			最大值：max


多个可供选取日期和时间的新输入类型<br>
	1、<input type="date" />选取年/月/日<br />
	2、<input type="month" />选取年月<br />
	3、<input type="week" />选取到一年当中的第几周，<br />
	4、<input type="time" />选取小时分钟<br />
	5、<input type="datetime-local" /><br />
	
	------------
	新增的表单属性
	一、pattern 属性
		语法： <input type="text" pattern="[A-Za-z]{3}"/>
		特点：[]限制允许输入哪些内容{}中写的是限制输入的位数（
		如果不写大括号中的位数，默认限制输入一位。）
		二、required
		语法：<input type="text" required />
		特点：验证文本框中是否输入内容。
		三、autofocus
		语法：<input type="text" autofocus=""  />
		特点：让当前文本框自动获取焦点。
		四、placeholder
		语法：<input type="text" placeholder="提示信息" />
		特点：可以提示信息，当开始往文本框中输入文字的时候，提示信息消失，
		当文本框的内容全部删除时，提示信息出现。
		五、form属性
		重置按钮：<input type="reset" />
		语法：
		<form action="" id="id1"></form>
		<input type="text" form="id1" />
		特点：可以让表单外input属于某个form


下拉框：
		<input list="id1" />
		<datalist id="id1"> 
			<option value="110"></option>
			<option value="120"></option>
			<option value="119"></option>
		</datalist>
		
	-------------------------
	选择器：最终目的选到某个或者某些标签
	一、基本类型选择器：
	1、 *     通配符选择器    会选到页面中的所有标签；   
	2、div/p  标签选择器      会选到页面中相匹配的标签；
	3、.class   类选择器    会选到页面中相匹配相对应的类名的标签；
	4、#        ID选择器
	id选择器和类选择器的区别：
	id选择器的优先级高于class
	id具有唯一性，
	一个标签可以有多个类名（如果多个类名中出现同一个属性，遵从就近原则）
	一个类名可以使用多次
	二、关系选择器：
	1、群组选择器：  一组相匹配的标签
	div,p,.box,#id1,ul
	2、后代选择器
	div p
	3、子代选择器
	div>p	


		div p    
		后代选择器，选到div下边所有的P标签
		div>p
		子代选择器，选到直接子元素。
		div+p
		相邻兄弟选择器
		以加号(+)分隔，紧邻，紧贴这个本元素的下一个兄弟元素会被选中
		div～p
		兄弟选择器
		以波浪线（~）分隔 本元素后的所有该名称的兄弟都会被选中，强调是之后的
		三、属性选择器
		1、拥有属性名         div[class]  会选中，所有包含规定属性名的标签。
		2、拥有属性名=属性值   div[class="head"]选到了页面中所有类名为head的div
		3、属性名包含属性值    div[class~="head"]选到了页面中所有类名包含head的div
		4、属性值以什么开头	 div[class^="he"]选到了页面中所有类名以he开头的div
		5、属性值以什么结尾    img[src$="png"] (选到了页面中所有png格式的图片) 
		6、属性值包含什么      img[src*=".jpg"](选到了页面中所有jpg格式的图片) 
		四、伪类选择器：
		1、a：hover   鼠标悬停时
		a：visited 访问过的
		a：link    正常显示
		a：active  激活时
		2、E:nth-child(n)    父元素中第几个子元素（必须叫e）
		3、E:nth-child(2n)   父元素中表示几的倍数的子元素集，2可以替换成任何数字
		4、 e:nth-child(odd)  父元素中的奇数子元素
		5. e:nth-child(even)  父元素中的偶数子元素
		6、e:first-child    父元素的第一个子元素（必须叫e）
		7、e:last-child   父元素的最后一个子元素（必须叫e）
		8、e:nth-last-child(n) 父元素中倒数第几个子元素
		9、e：nth-of-type（n）    在父元素中叫e的第几个子元素
			和nth-child的区别：  E：nth-child(n)选到是第几行，然后这一行必须是E，否则 什么都选不到
			而E：nth-of-type（n） 选到是叫做e的第几个元素。
		10、e：first-of-type    选到叫做e的第一个元素
		11、e：last-of-type    选到叫做e的最后一个元素
		12、e:nth-last-of-type()选到叫做e的倒数第几个元素


伪类对象选择器
		修改placeholder属性的字体颜色；    
		::-webkit-input-placeholder
		：before  在什么之前
		：after   在什么之后
		
		优先级等级：
		具有继承性的属性：所有字体相关的样式都有继承性
		
		important > 内联 > ID > 类 > 标签 | 伪类 | 属性选择 > 伪对象 > 继承 > 通配符
	
	浏览器的私有化前缀：
		主流浏览器：
		
		谷歌      -webkit-
		
		IE        -ms-
		
		火狐       -moz-
		
		欧朋       -o-
		
		Safari    -webkit-


1、英文单词：
		red、yellow 、green。。。
		transparent  透明色
		2、十六进制编码：
		#ffffff  
		#：十六进制  ffffff颜色编码；
		简写：
		同时满足：
		1、2位相同可以简写为一位、
		3、4位相同可以简写为一位、
		5、6位相同可以简写为一位、
		#111123----->  不能简写
		#122334----->  不能简写
		#112233----->#123
		取值：0-9，a-f
		3、rgb
		颜色三原色： 
		r red   红色
		g green 绿色
		b blue 蓝色
		取值范围：0-255
		语法：color：rgb(2,3,4) background:rgb(200,23,56)
		rgba带有透明度的写法：
		a的取值：0-1；
		透明度的表现形式：
		opacity 透明度  取值0-1
		两种透明度的区别 rgba中的a属于属性值只属于color或者背景色。
						opacity中的透明度属于使用它的元素。
						所以会导致，rgba不会影响盒子内容，
						而opacity会影响；
		4、HSL表现颜色：
		1. 含义
		HSL 指的是 
		hue（色调）、
		saturation（饱和度）、
		lightness（亮度） - 表示颜色柱面坐标表示法
		----
		background-attachment: fixed;background-attachment: fixed;
    background-position: center 0;
    background-repeat: no-repeat;
    background-size: cover;
css 说明 

　　background-image:url("图片的网址"); 背景图 

　　background: url(" 图片的网址 "); 背景 

　　background-color:#色码; 背景色彩 

　　Exp: 

　　background-image:url(背景图案.jpg,gif,bmp); 

　　background-color:#FFFFFF; 

　　background-color : transparent; <--设定背景为透明色 

　　background-repeat 改变背景图片的重复并排的设定 

　　css 

　　 说明 

　　repeat 背景图片并排 

　　repeat-x 背景图片以X方向 并排 

　　repeat-y 背景图片以Y方向 并排 

　　no-repeat 背景图片不 以并排的方式处理 

　　Exp: 

　　background-image:url("http://webdesign.chinaitlab.com/UploadFiles_8014/200903/20090323115920230.gif"); 

　　background-repeat:no-repeat; 

　　以http://webdesign.chinaitlab.com/UploadFiles_8014/200903/20090323115920230.gif这张图片为背景，当图片大小不够的时候，不并排重复 

　　background-attachment是否固定图片位置 

　　css 

　　说明 

　　scroll 拉动卷轴时，背景图片会跟着移动（缺省值） 

　　fixed 拉动卷轴时，背景图片不会跟着移动 

　　Exp: 

　　background-image:url("http://webdesign.chinaitlab.com/UploadFiles_8014/200903/20090323115920230.gif"); 

　　background-repeat:no-repeat; 

　　background-attachment:fixed; 

　　以http://webdesign.chinaitlab.com/UploadFiles_8014/200903/20090323115920230.gif背景图片不重复并列，且不随卷轴移动 

　　以长度定位background-position: x y 

　　使用百分比定位 background-position: x% y% 

　　css 

　　说明 

　　x% 往右移 

　　y% 往下移 

　　backgroud-position: 0% 0%; 左边上方 

　　backgroud-position: 0% 50%; 左边中间 

　　backgroud-position: 50% 0%; 中间上方 

　　backgroud-position: 50% 50%; 正中间 

　　backgroud-position:100% 0%; 右边上方 

　　backgroud-position: 0% 100%; 左边下方 

　　backgroud-position: 100% 50%; 右边中间 

　　backgroud-position: 50% 100%; 中间下方 

　　backgroud-position: 100% 100%; 右边下方 

　　以关键字定位 

　　关键字 说明 

　　top 上 ( y = 0 ) 

　　center 中 ( x = 50, y = 50 ) 

　　bottom 下 ( y = 100 ) 

　　left 左 ( x= 0 ) 

　　Exp: 

　　background-position:center; 

　　图片在指定背景中央X=50% Y=50%位置 

　　background-position: 200px 30px
分类: Css
   		 background-position: center 0;
   		 background-repeat: no-repeat;
   		 background-size: cover;
		字体相关：
		
		font-size   字体大小：
		  px  绝对单位
		  em  相对单位：
		  根据父元素的font-size值来确定大小。
	    font-weight  字体加粗
	    		bold    加粗
	    		
	    		normal  正常（默认）
	    		
	    		固定数值：100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | 
	    	font-style 字体样式
	    	italic斜体
	    	
	    	font-family  字体种类/类型
	     Heiti,	"黑体", "Microsoft YaHei", "微软雅黑", SimSun, "宋体"
	     
	     color  字体颜色： 所有的颜色模式都可以使用。

边框线：
		border:(复合属性)
		border-width：边框宽度
		正整数的取值+
		solid  实线边框
		dotted 点状虚线
		dashed 间隔虚线；
		double：双线轮廓。
		groove：3D凹槽轮廓。
		ridge：3D凸槽轮廓。
		inset：3D凹边轮廓。
		outset：3D凸边轮廓。
		border―color：边框颜色；
		所有的颜色形式都可以使用
		----边框线的应用：
		三角形：
		.box{
				width: 0px;
				height: 0px;
				border-top: 50px solid transparent ;
				border-bottom:50px solid green;
				border-right:50px solid transparent ;
				border-left:50px solid transparent ;
			}
			二、轮廓线：
			轮廓线时不会让盒子的宽高增加；
			去掉默认样式轮廓线：
			input{
				outline: none;
			}
			修改轮廓线样式
			input:focus{
				outline: 2px solid orange;
			}
		------
		边框圆角：border-radius
		一个值：四个角
		两个值：第一个值：左上右下；第二个值左下右上
		三个值：第一个值：左上；第二个值：左下右上；第三个值：右下；
		四个值：顺时针方向依次影响；
		正圆：border-radius：50%
		椭圆：border-radius：50%
		宽高不一样；
		-----
		盒子阴影：
		box-shadow：X 轴偏移 Y轴偏移 模糊程度 阴影面积 颜色 
		X轴：值越小越往左，值越大越往右
		Y轴：值越小越往上。值越大越往下
		模糊程度：负值是不允许的
		盒子内阴影：
		box-shadow：inset X 轴偏移 Y轴偏移 模糊程度 阴影面积 颜色
		文字中阴影：
		text-shadow： X轴偏移 Y轴偏移  模糊程度 颜色；
		多阴影
		text-shadow： X轴偏移 Y轴偏移  模糊程度 颜色 ,X轴偏移 Y轴偏移  模糊程度 颜色;
 		文字描边text-stroke：
		文字的填充text-fill-color；当设置文字填充的时候，color是不起作用的；



		------
		三、文字溢出隐藏：text-overflow
		overflow: hidden;
		负责文本溢出时隐藏
		white-space: nowrap;
		强制不换行
		text-overflow: ellipsis;
		溢出隐藏的时候以哪种状态显示
		ellipsis以。。。形式显示
		clip:文本溢出时裁切，不出现...
		四、垂直对齐方式：vertical-align（依赖于display：inline-block）
		top：将支持valign特性的对象的内容与对象顶端对齐
		middle：将支持valign特性的对象的内容与对象中部对齐
		bottom：将支持valign特性的对象的文本与对象底端对齐
		1、背景属性：
		背景：background：（复合属性）
		background-color   背景颜色
		颜色的表现形式都可以使用
		background-image  背景图片
		url  （相对路径）同时使用背景颜色和背景图片的时候只会显示背景图片；
		引入多张背景图片：
			background-image: url(img/jpg01_03.jpg),url(img/4.jpg);	
			background-size:100px 100px,100px 100px ;
			background-position:left,right top;
			background-repeat: no-repeat;
		background-position背景定位
		1. 英文参数
			center：背景图像横向和纵向居中。
			left：背景图像在横向上填充从左边开始。
			right：背景图像在横向上填充从右边开始。
			top：背景图像在纵向上填充从顶部开始。
			bottom：背景图像在纵向上填充从底部开始。
		2、
		background-size    背景尺寸
		1、百分比   第一个值指的是横向，第二个值是纵向；
		2、具体数值  第一个值指的是横向，第二个值是纵向；
		3、cover：将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。
		4、contain：将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内。
		5、auto
		background-repeat  背景是否重复
		默认是重复
		横向重复：	background-repeat:repeat-X
		不重复：no-repeat


	1、线性渐变
	 linear-gradient
	默认： background: linear-gradient(red,yellow);从上往下变，
	指定方向：
	to：往哪个方向变就to哪个方向。
	background: linear-gradient(to right,red,yellow);
	兼容性写法：
	  background: -webkit-linear-gradient(left, red , yellow);兼容谷歌
      background: -o-linear-gradient(right, red, yellow);兼容欧朋
      background: -moz-linear-gradient(right, red, yellow);兼容火狐
      background: linear-gradient(to right, red , yellow);现在的写法
     有角度的渐变：
     deg角度
     background: linear-gradient(45deg,red,yellow);
     随着角度增加起始位置会有一个顺时针方向的改变。
     有范围的线性渐变：
     background: linear-gradient(45deg,red 10px,blue 30px,green 90px);
     颜色后边的数值代表的是从第多少px/百分比开始出现该颜色。
     重复线性渐变：
      background: linear-gradient(45deg,red 1 0px,blue 30px,green 90px);
	 2、径向渐变
	 radial-gradient
	 background：radial-gradient（green,red）默认从里往外变
	 指定渐变开始位置：at  at哪个方向就从哪个方向开始
	 background:radial-gradient(at top,red，green);
	 径向渐变的形状：
		
		
		
		一、过渡   transition （复合属性）
		1、transition-property属性    定义哪个样式需要进行过渡变化。 
			如果多个属性进行变化，可以逗号或者空格把属性隔开。或者用all代替属性。
		2、transition-duration属性   定义过渡持续的时间。
		3、transition-delay属性     定义延迟时间。多久之后开始执行过渡。
		4、 transition-timing-function属性  缓动函数，定义过渡的运动状态
			运动状态：
			ease        		逐渐变慢
			linear       	匀速运动
			ease-in     		加速运动
			ease-out    		减速运动
			ease-in-out  	先加速后减速


transform     动画方式
		
		-----
		1. 旋转 rotate()
		rotateX()    以横向坐标轴为旋转基点  
		rotateY() ： 以纵向坐标轴为旋转基点
		rotateZ() :  默认。
		2. 扭曲skew()
		skewX()   默认值
		skewY()
		3.translate()
		translateX()  沿着水平方向位移，如果为正值往右移，负值往左移
		translateY()  沿着垂直方向位移，如果为正值往下移，负值往上移
		4. 缩放 scale()
			transform: scaleX(1.5);//x轴缩放
 			transform: scaleY(1.5);//y轴缩放
  			transform: scale(0.5);//x轴缩放
  			transform: scaleX(-1);//x轴水平翻转
  			transform: scaleY(-1);//y轴垂直翻转
  	1. 什么是基点?
		基点就是元素用于移动的基础点在什么位置,默认是左上角
		transform-origin: left左 | center 中| right 右|bottom下
						left bottom |

一、3d
		1、景深
		perspective透视(景深) perspective属性的存在与否决定了你所看到的是2次元的还是3次元的；
		简单理解：近大远小的成像原理。
		写给父元素；
		取值一般在500px至800px之间；
		2、3d空间
		transform-style:preserve-3d ；声明一个3d舞台/3d空间。
		加给要进行3d变换的元素的父元素。
		transform：translateZ 沿着Z轴位移。
		二、动画
		1、关键帧： keyframes
		@ keyframes 关键帧名称：
		2、动画：animation（复合属性） 
		和过渡属性的区别：过渡适合足一些简单的动画效果，而，
		animation属性却可以实现复杂的动画效果，
		1、animation-name	动画名称（关键帧名称）
		2、animation-duration	动画持续时间
		3、animation-delay	动画延迟 
		4、animation-iteration-count	重复次数
			infinite为无限次/具体数值
		5、animation-fill-mode属性规定动画在播放之前或之后，其动画效果是否可见
			animation-fill-mode : none | forwards 
		6、animation-play-state 播放状态（ running 播放 和paused 暂停 ）
		7、 animation-direction	播放前重置
		  alternate	动画直接从上一次停止的位置开始执行
		  normal	动画第二次直接跳到0%的状态开始执行

REM ：是CSS3新增的一个相对单位
	   （root em，即根em）
		REM是相对单位，是相对HTML根元素。 
		rem的换算：
		1.拿到设计图后，首先要测量设计图的宽度。
		2.用设计图的宽度替换clientwidth 然后就求商。相除得到的结果 X  这个值不能小于12。
		3.用设计图中任意某个位置所量取到的具体大小（px）／X=这个位置的rem值。
		
	<script> 
	window.onload = function() {   
     	document.documentElement.style.fontSize=document.documentElement.clientWidth/16+'px';        
	window.onresize = function() {            
     document.documentElement.style.fontSize=document.documentElement.clientWidth/16+'px';        };
 	};
	</script> 
		
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
第一点：因为现在我们用的智能手机（iOS，Android）的浏览器都是基于webkit内核，这里有一些针对webkit的特殊meta标签，在开 发移动端web是起到很重要的作用： <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"> 强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览；
<meta content="telephone=no" name="format-detection"> 告诉设备忽略将页面中的数字识别为电话号码
width [pixel_value | device-height]当前设备宽度
height [pixel_value | device-height]当前设备高度
user-scalable 是否允许缩放 （no||yes）
initial-scale 初始比例
minimum-scale 允许缩放的最小比例
maximum-scale 允许缩放的最大比例
第二点：HTML5标签的使用 可以减少开发者很多的工作量，当然了你决定使用HTML5前，一定要对此非常熟悉，要知道HTML5的新标签的作用。比如定义一块内容 或文章区域可使用section标签，定义导航条或选项卡可以直接使用nav标签等等。


因为在移动端的浏览器中webkit内核的比率占了主导地位所以我们可以在移动端开发的时候尽情的使用新增的H5标签以及CSS3的新属性而不需要去考虑它的兼容性问题了。

第三点：放弃CSS float属性――建议
在项目开发过程中可以会遇到内容排列显示的布局，假如你遇见这样的视觉稿，建议尽量放弃float，可以直接使用display:inline-block;
第四点：块级化a标签
请保证将每条数据都放在一个a标签中，为何这样做？因为在触控手机上，为提升用户体验，尽可能的保证用户的可点击区域较大
第五点：如何解决盒子边框溢出

当你指定了一个块级元素时，并且为其定义了边框，设置了其宽度为100％。在移动设备开发过

程中我们通常会对文本框定义为宽度 100％，将其定义为块级元素以实现全屏自适应的样式，但

此时你会发现，该元素的边框(左右)各1个像素会溢了文档，导致出现横向滚动 条，为解决这一

问题，我们可以为其添加一个特殊的样式-webkit-box-sizing:border-box;用来指定该盒子的大小

包括边框的宽度。




	第三个月




一、什么是JavaScript?
		JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型.
		何为脚本语言：
		脚本语言通常以文本保存，只有在被调用的时候才会进行解释式的编译。css和html不同js地方在于，不触发也会运行。
		动态类型、弱类型：  用var定义变量，不需要指定具体类型，类型是通过运行时自动检测的
		二、
		html       描述的是网页内容；
		css        描述的是网页的样式；
		javascript 描述的是网页行为；
		三、JavaScript的组成部分
		1、 ECMAScript  核心语法；
		2、 DOM 文档对象模型：操作页面用的。
		3、 BOM 浏览对象模型  与浏览器交互的方法。
			ECMAScript 核心语法：包括
			1、语法
			2、类型
			3、语句
			4、关键字
			5、保留字
			6、操作符
			7、对象
		四、JS的三种输出方式：
		alert（）           弹出窗口
		console.log( )      在控制台输出
		docment.write()      在当前页面写入
		五、JavaScript引入方式：
		1、在行内直接写js代码；
		2、在script标签中写js代码；
		3、新建一个js文件<script src="js/index.js"></script>
		六、第一个事件：onclick
		在标签中使用点击事件：<div onclick="alert(111)"></div>
		 					<div onclick="alert("第一个弹出")"></div>
			根据id获取页面中的某个元素：
			document.getElementById('id名')
			
			document  文档，（当前页面）
			get        获取
			Element    元素
			By         通过
			Id         ID
			.          的
			获取元素后设置其样式：
			document.getElementById('id名').style.width='400px';
			
		七、创建函数：
		function 函数名(){}
		简单理解函数：函数就是包裹在花括号中的代码块，前面使用了关键词 function：
		JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数。
		通过函数名调用
		八、变量:JS中的变量是松散型，所谓的松散类型就是可以用来保存任何类型的数据。
			简单的说变量就是用于保存值的占位符。
		如何定义一个变量
		要使用var操作符（var是js中的关键字）后跟变量名在定义一个变量的时候可以直接设置变量的值
		在函数内部的变量我们可以称之为局部变量；
		在函数外部的变量我们可以称之为全局变量；


数据类型：
		变量的数据类型是根据它所存储的数据类型确定；
		引用数据类型：object
		基本数据类型：Number  数字类型 String      字符串类型 Boolean  布尔类型 Undefined 未定义 Null空        
		怎么确定是哪种数据类型：
		操作符：typeof()
		null  类型：Null是引用类型的空值，表示一个空指针对象，即初始化的值是一个对象（引用类型），而不是一个基础数据类型。
		typeof（null）
		为object；		
		undefined  未定义；
		Undefined类型只有一个值：undefined。当声明变量后，未初始化赋值的情况下，变量为Undefined类型。

		Boolean   布尔型；
		两个值：
		true  真 
		false 假
		其他类型数据转换为Boolean类型数据――Boolean()方法
		数据类型		转换为true		转换为false
		Boolean		true			     false
		String		非空字符串		空字符串
		Number		非零数值		    0和NaN
		Object		任何对象		    null
		Undefined   n/a(不适用)		undefined
		基本数据类型：
		Number    数字类型；
			Number（）：把当前数据类型转换为数值。(任何数据类型都可以转换)
			会把布尔型数据  true转换成1；
								    false转换为0；
						
					
					转换字符串的时候：字符串中只包含数字，直接转换为数字
									字符串是空值；转换为0
									字符串中如果有前导0，前导0被省略；
									除了以上三种情况，其他都会被转为NaN；
					undefined:     转换成NaN；
					null：          转换成0；
					number： 直接转换为数字；
			parseInt()方法：
				把当前数据类型转换为整数值(取整)
				转换规则：
				1、不包含数字的值，都转换为NaN。
	       		2、包含数字的值：
				（1）整数：直接输出，返回原值。
				（2）浮点数：去掉小数，返回整数，不四舍五入。
				（3）有前导0，删除前导0。
				（4）如果数字，字符串混合，取第一个非数值前的数字。
			parseFloat()方法：
			把当前数据类型转换为浮点数。
				转换规则：
				1、不包含数字的值，都转换为NaN。
	      	 2、包含数字的值：
				（1）整数、浮点数：直接输出，返回原值。
				（2）有前导0，删除前导0。
				（3）如果数字，字符串混合，遇到一个无效的浮点数为止。
			1、整数型
		2、浮点型
		3、NaN :常用于表示应该返回一个数值，但未返回数值的情况。
		   NaN有两个特点：
				1、任何涉及NaN的操作都返回NaN。
				2、NaN和任何值都不相等。
		isNaN();判断是不是不是一个数字；
		可以转换为数值返回flase；
		不可以转换为数值返回true；


	JavaScript 字符串用于存储和处理文本,一种基本的数据类型。
	符串可以是插入到引号中的任何字符。你可以使用单引号或双引号：
	需要注意的是单引号和双引号不能混用。
	字符串长度属性length。var str="helloo";   alert(str.length);
	1、toString（）  可以把 数值，布尔类型，字符串值转换成字符串类型；
		语法： 变量名.toString()；
	2、String（）   可以把任何数据类型都转换成字符串类型。
		语法：String（变量名）；
	注意两者的区别。String（）是可以将所有的基本数据类型转换成字符串类型，而toString只能将数值，布尔类型，字符串转换为字符串
	3、toLowerCase?()
	作用：把字符串转成小写。
	语法：字符串. toLowerCase()?	参数：无参?	返回值：返回字符串转成小写的结果，原来的字符串不有变化
	4、toUpperCase()
	作用：把字符串转成大写。?	语法：字符串. toUpperCase()?	参数：无参?	返回值：返回字符串转成大写的结果，原字符串不变。
	5、charAt（number）
		作用：通过索引找字符。?
		语法：字符串.charAt(number)?
		参数：索引值index（取值从0到length-1），若无参数，默认为0。?
		*9返回值：返回取到的那个字符，类型为字符串；如果number超出范围返回一个空。
6、indexOf?作用：通过字符找下标（从左往右找这个字符首次出现的位置）。
		语法：字符串.indexOf(searchValue,fromIndex)?
		参数：searchValue?要查找的字符；
			 fromIndex?从哪个位置开始找，这个参数若无默认为0?
		返回值：如果找到，返回一个数字，这个数字是字符在字符串中的真实下标值。如果没找到的话返回-1。
	7、lastIndexOf?作用：通过字符找下标（从右往左找字符也就是说最后一次出现的位置）。
		语法：字符串.lastIndexOf(searchValue,formIndex)?
		参数：同indexOf。?
		返回值：同indexOf。
	8、slice?
		作用：截取字符串。?
		语法：字符串.slice(m,n)?
	参数：?
		- 从索引m处开始截取到n处（不包含n）；?
		- 若只有一个参数时，就是从参数截取到最后；?
		- 若无参数时，直接返回整个字符串（克隆）；?
		- 参数可以为负数，但开始位置不能大于结束位置，开始位置是最后一位，代表-1 。?返回值：截取到的字符串，原字符串不变。
	9、substring?
		作用：截取一段字符串?
		语法：字符串.substring(m,n);?
		参数：从m处截取到n处（不包含n）?
		- 若无参数、或参数为0时返回整个字符串（克隆）?
		- 若一个参数则从参数位置截取到最后?
		返回值：截取后的字符串，原字符串不改变
		―――――――――――――――――――――――――――――――――――
		与slice的区别：?
		1、slice起始位置不能大于结束位置，而substring起始位置可以大于结束位置?
			如果起始位置比结束位置大，那么该方法在提取子串之前会先交换这两个参数。
		2、slice可以放负数，而substring是不能放负数的
	10、substr?
		作用：截取字符串。?
		语法：字符串.substr(m,count)?`
		参数：从索引m处截取以count个字符?
		- 若一个参数则从参数位置截取到最后。?
		- 若无参数或参数为0会把整个字符串返回（克隆）。?
		返回值：返回取到的字符串，原字符不变。

12、trim?（）
		作用：去掉字符串首尾空格。?
		语法：字符串.trim()?
		参数：无参?
		返回值：返回去了首尾空格的字符串，原不改变。
		trimLeft（）去掉左边的空格。trimRight（）去掉右边的空格。
------------------------------------
	1、算数运算符	   +、-、*、/、%、++、--、**
	2、赋值运算符	   =、+=、-=、*=、/=、%=
	3、关系运算符	   ==、===、！=、！==、>、<、>=、<=
	4、逻辑运算符	   &、|、^、！、&&、||
	5、位运算符	   &、|、^、~、<<、>>、>>>
	6、条件运算符	   条件？Exp1:Exp2
	一、算数运算符
		加法运算规则：
	1、数字和数字相加，得两数和
	2、字符串与任何数据类型值相加，得字符串与该类型值合并的新字符串
	3、非数字、非字符串类型进行加法运算时，先转为Number类型后再进行加法运算。
	减法运算规则
	1、数字和数字相减，得两数差
    2、非数字类型进行减法运算时，先转为Number类型后再进行减法运算。
	乘法运算规则
	  1、数字和数字相乘，得两数积
      2、非数字类型进行乘法运算时，先转为Number类型后再进行乘法运算。
		除法运算规则：
      1、数字和数字相除，得两数商
      2、非数字类型进行除法运算时，先转为Number类型后再进行除法运算。
      求余（求模）运算规则：
      1、被除数小于除数求余，得被除数。
      2、非数字类型进行求余运算时，先转为Number类型后再进行求余运算。
      ------------------------------
      自加、自减运算规则：
      1、后自加、自减运算：先带入运算，后自加或自减1。var a=1； a++ 
      2、前自加、自减运算：先自加或自减1，后带入运算。var a=1； ++a
      -----
      关系运算符
		完全等于运算符：==	（判断两个数据的值是否相等）
		如果两个操作数相等则返回true；
		绝对等于运算符：===	（判断两个数据的类型是否相等，再判断值是否相等。）
		完全不等于运算符：！=	 （判断两个数据的值是否不相等）
		如果两个操作数不想等则返回true；
		绝对不等于运算符：！==（判断两个数据的类型是否不相等，再判断值是否不相等。）
			等于和不等于运算符规则：
    		1、Number类型、String类型、Boolean类型转为Number类型后判断是否相等。
      	2、Undefined类型、Null类型不转为Number类型。
      	3、undefined和null相等。
      	4、如果有一个操作数是NAN那么在等于操作符中返回false，在不等于操作符中返回true。
		 >、大于
     	 <、小于
      	 >=、大于等于
         <=、小于等于
        比较规则和我们数学课上所学的一样，这几个操作符依然是返回一个布尔值。/>
		如果是非数值进行比较时的规则
		如果两个数都是数值，则执行数值比较
		如果两个操作数都是字符串，则比较两个字符串对应的字符编码
		如果一个操作数是数值，则将另一个操作数转换为一个数值。然后执行数值比较。
		如果是一个布尔值。则先转换为数值进行比较
		--------
		逻辑与（& & ）（并且）
		会将操作数转换为Boolean类型
		两个表达式都成立的情况下返回true，第一个不成立则返回false；第一个表达式如果是错误的会直接不验证第二个表达式
		第一个值          第二个值           返回
		true               true            true
		true               false           false
		false              跳过第二个值      false
		逻辑或（||）（或者）
		会将操作数转换为Boolean类型
		两个表达式都成立的情况下返回true，两个表达式中有一个成立则返回true；第一个表达式如果是正确的会直接不验证第二个表达式
		第一个值          第二个值           返回
		true              跳过第二个值       true
		false             true              true
		false              false            false


	逻辑非运算符：！		
	    （判断表达式或值的返回值，如果为真返回false,否则返回true）
		逻辑非会将他的操作数转换为一个布尔值。然后再对其求反。
		也就是说正常是true的值在遇到逻辑非的时候都会返回false；
		使用两个逻辑非操作符会和Boolean（）非常类似
		条件运算符：条件？Exp1:Exp2
		（判断条件表达式，如果为true，返回Exp1执行结果, 否则返回Exp2执行结果）
		语法：var max=（num1>num2）?num1:num2; //

什么时候需要用到传参？
		里边改的东西不确定的时候可以用传参。
			形参：函数小括号中name , age 为形参。
实参：调用函数，初始化参数时的参数为实参。


一、JS的流程控制：
		一、顺序流程
				
		二、选择结构
		    由if……else 、switch语句来实现选择结构
		    单分支结构
			如果条件不满足，代码块不执行；
			条件可以是任意表达式，而且对每个表达式值的要求不一定是布尔值，
			在这里会自动调用Bollean()方法将这个表达式的结果转换为一个布尔值。
			If……else语句分为：单分支结构、
			if(条件表达式){
				要执行代码块
			}
			双分支结构
			if(){
				
			}else{
				
			}
			多分支结构
			if(){
				
			}else if(){
				
			}else{
				
			}
			switch选择分支语句 必须与 case （比较值） break(跳出语句) default（相当于else）一块使用
				switch (){
					case value:
						break;
					default:
						break;
				}


一、while语句
		var num=“变量初始化”;
		While（循环条件）{
			循环语句；
			迭代语句；
     	}

		var num=“变量初始化”;
		    do{
			循环语句；
			迭代语句；
			} While（循环条件）

			do/while 循环是 while 循环的变体。该循环会执行一次代码块，再检查条件是否为真，然后如果条件为真的话，
			就会重复这个循环。也就是说循环体的代码至少会被执行一次
		
		获取一组元素的方式
		document.getElementsByTagName('li')；
	    
	    document  当前页面
	    getElements  获取一组元素
	    By        通过
	    TagName   元素名称
	    
	    获取到的是一组元素，但凡是一组元素都会有length这个属性。
	    length这个属性出现就意味着会有下标
		那就可以通过下标取出一组元素中的某个元素
		语法：aDiv[0];代表第一个div；
		解决必须把JS写在html结构下边的方法
		把所有的JS写在window.onload=function(){}中
		window.onload表示当前窗口加载完后执行；


	for 循环
		<script type="text/javascript">
			
			for (初始化变量,循环条件,迭代语句()) {
				需要重复去做的那件事.
			}
			
			
			
		for 循环中的
			例：	var num=0;
		   for(var i=1 ; i<10 ; i++){
			if( i%5==0 ){
				break;
			}
			num++;
		    }
		    alert(num);
          会立即跳出循环，执行下边的语句   终止操作；
          continue语句
          var num=0;
		  for(var i=1 ; i<10 ; i++){
			if( i%5==0 ){
				continue;
			}
			num++;
		  }
		 alert(num); 跳过操作还会在符合循环条件的情况下执行循环
		</script>




		JS获取DOM元素的方法（8种）
	通过ID获取（getElementById）
	用法：上下文必须是document、必须传参数，参数是string类型，是获取元素的id、返回值只获取到一个元素，没有找到返回null。
	通过name属性（getElementsByName）注意返回的是一个类数组，所以注意下标的使用
	上下文必须是document必须传参数，参数是是获取元素的name属性 返回值是一个类数组，没有找到返回空数组
	通过标签名（getElementsByTagName）
	上下文可以是document，也可以是一个元素，注意这个元素一定要存在.参数是是获取元素的标签名属性，不区分大小写
	意思就是可以这样去获取P标签 ：
	document.getElementsByTagName('p');
	var oDiv = document.getElementById('divId');
	oDiv.getElementsByTagName('p');
	通过类名（getElementsByClassName）
	上下文可以是document，也可以是一个元素用法和getElementsByTagName用法相似参数是元素的类名
	获取html的方法（document.documentElement）
	获取body的方法（document.body）
	通过选择器获取一个元素（querySelector）
	上下文可以是document，也可以是一个元素，.参数是选择器，如："div .className";返回值只获取到一个元素
	document.querySelector(div .className)....
	通过选择器获取一组元素（querySelectorAll）
	document.querySelectorAll(div .className)....
		注意返回的是一个类数组，所以注意下标的使用
--------------------
	批量设置css样式
	cssText
	oDiv.style.cssText=xxx
	优点： 方便，可以一次设置各种样式，缺点：一次会改变一堆属性，而且不认识浏览器私有化前缀
	----------------------------
		arguments对象（不定型参数）
		arguments对象：在函数体内具有数组功能的一个对象。但不是数组对象的实例（即不是数组类型）。
		arguments对象作用：保存函数实参。
		1、函数声明后，函数体内就存在了arguments对象。
		2、函数调用，初始化实参时，实参按照顺序保存在arguments对象中。
		3、通过下标值可以访问arguments对象中保存的实参值。
		4、arguments对象只能在函数中使用。
		 function hello(){
	     console.log(arguments[0],arguments[1],arguments[2]);
       	}
       	hello(10,20,30,40)
		随便输入几个数字计算和；
			//定义一个变量为he，初始值是0，用于储存和
			var he=0;
			function jisuan(num){
				for (var i=0;i<arguments.length;i++) {
					
					he+=arguments[i]
				}
				alert(he);
			}
			//调用函数计算并传入10,20,30,40
			jisuan(10,20,30,40)
返回值：给函数返回一个值，并终止函数也就是会所在return后边的语句不再执行。
引用数据类型:
		引用数据类型：即对象类型（Object）。
		Object类型是所有对象类型的父类型。
		其他对象类型：
		Array类型、Date类型、Function、RegExp、基本包装类型（Number类型、String类型、Boolean类型）
		什么是对象:
		对象是由不同的属性和行为（也称为方法）组成。
		例：人对象。
		人的属性：名字、年龄、性别、身高等。
		人的行为：说话、跑步、吃饭、唱歌等。

Array类型（数组类型）
		 Array类型可以保存不同类型的数据。  最好只存一种数据类型
		 Array类型的大小可以动态调整


数组操作的方法:
		push（）：数组尾项添加任意数值。arr.push(要添加的数据)
		pop（）: 移除数组末尾项arr.pop();
		unshift（）: 数组首项添加数据 arr.unshift(要添加的数据)
		shift（）：删除数组首项。arr.shift()
		splice（）： 插入、替换、删除 数组项
		splice(开始, 长度,元素…)
		先删除，后插入 删除	
		splice(开始,长度)
		插入	splice(开始, 0, 元素…)
		替换	splice(开始, 长度, 元素)	
		删除：var arr=[1,2,3,9,8,7];
			 arr.splice(1,2);
		插入：var arr=[1,2,3,9,8,7];
	 		 arr.splice(1,0,"red");
		替换：var arr=[1,2,3,9,8,7];
	 		arr.splice(1,2,"red");
	 	concat（）：合并数组。
	 	var arr1=[1,2,3,4,5,6];
		var arr2=[1,2,4,99,11,22];
		var arr3=arr1.concat(arr2);
		sort（）和reverse（）
		sort（）：数组升序排序。
		reverse（）：反转数组。、
		用 循环做一下数组反转：
		var a=[1,4,3,6,2,9];
			//创建一个空数组
			var newArr=[];
//			for( var i=a.length-1;i>=0;i--){
//				//newArr+=a[i];
//				newArr.push(a[i]);
//			}
//			alert(newArr);
		/把a的初始长度保存起来
		var naozi=a.length;
		//从下标0开始。小于a的长度，每次递增
		for (var i=0;i<naozi;i++) {
			//往新的数组里去挨个push，弹出的数组a的最后一个值
			newArr.push(a.pop())
		}
		alert(newArr);
			-------
	   数组.sort()如果不写参数 默认是按Unicode码进行排序
		return a-b 从小到大进行排序  a<b从大到小进
		行排序
		function des(a,b){//降序
		return b-a;
		}
		function asc(a,b){//升序
		return a-b;
		}
		slice（）: 截取数组。参数如果是负数，用数组长度加参数后截取。如果起始数大于结束数，返回空数组。
		indexof（）：查找数组中数据位置。如果数组中没有要查找的数据会返回-1;
		lastIndexOf（）:倒序查找数组中数据位置。

定时器：
		定时器是什么呢
		两种。
		setInterval。      不间断执行
		setTimeout.       延迟执行一次
		创建一个定时器
		setInterval（'函数名',时间)

	Date创建语法  var  data=new Date();
	直接获取当前时间为标准时间
	date.getFullYear()　　//2017　　从 Date 对象以四位数字返回年份
　　date.getMonth()　　//11　　从 Date 对象返回月份 (0 ~ 11)
　　date.getDay()　　//2　　从 Date 对象返回一周中的某一天 (0 ~ 6)
　　date.getDate()　　//12　　从 Date 对象返回一个月中的某一天 (1 ~ 31)
　　date.getHours()　　//23　　返回 Date 对象的小时 (0 ~ 23)
　　date.getMinutes()　　//30　　返回 Date 对象的分钟 (0 ~ 59)
　　date.getSeconds()　　//54　　返回 Date 对象的秒数 (0 ~ 59)


innerHtml
		innerHTML在JS是双向功能：获取对象的内容  或  向对象插入内容；
		如：<div id="aa">这是内容</div>   ，
		我们可以通过  document.getElementById('aa').innerHTML 来获取id为aa的对象的内嵌内容；
		也可以对某对象插入内容，如  document.getElementById('abc').innerHTML='这是被插入的内容';   
		这样就能向id为abc的对象插入内容。（实质是在给abc赋值）


Math对象:
	Math.max（）方法：求最大数
	例：	alert(Math.max(4,54,23,12,4));  //54
	Math.min（）方法：求最小数
	例：	alert(Math.min(4,54,23,12,6));  //4
	Math. ceil（）方法：向上取整
	例：	alert(Math.ceil(25.5));  //26
	alert(Math.ceil(25.1));  //26
	Math. floor（）方法：向下取整
	例：	alert(Math. floor(25.5));  //25
	alert(Math. floor(25.1));  //25
	Math. round（）方法：四舍五入
	例：	alert(Math. round(25.5));  //26
	alert(Math. round(25.1));  //25
	Math. random（）方法：获得0-1之间的随机数
	例：	alert(Math.random());  //0-1之间的随机数，。。。。。。。。
	alert(parseInt(Math.random()*10)); //0-9之间的整数
		随机数:
		Math.random() 方法可返回介于 0 ~ 1 之间的一个随机数。
		获取一个0-多少的随机数
		Math.random()*10 获取0-10的随机数
	   	 获取在什么区间的一个随机数
		获取指定区间范围随机数，包括lowerValue和upperValue
		function randomFrom(最小值,最大值)
		{	
?? ?			return Math.floor(Math.random() * (最大值 - 最小值 + 1) + 最小值);
		为什么要+1:因为Math.floor是向下取整所以需要加1。
		}






						第四个月




// JSON: 键值对 key-value  属性名-属性值  kv

		// 
		var json = {
			name:'zhang3',
			age:18,
			cat:{
				name:'老鼠'
			}
		} 


		// 点语法:只能点属性名 
		json.name;

		var k1 = 'name';
		console.log(json.k1);

		// []
		console.log(json[k1]);
		console.log(json['name']);

		// in
		console.log('name' in json);

		// 遍历对象
		for(var key in json){
			console.log(key);
			console.log(json[key]);
		}



		// http://www.demo.pho?user=ckk&pass=123
		/*
		{
			user:'ckk',
			pass:123
		}
		*/

		var s1 = 'http://www.demo.php?user=ckk&pass=123'; 
		var paramsStr = s1.split('?')[1];
		var params = paramsStr.split('&');//['user=ckk', 'pass=123']
		var obj = {};
		params.forEach(function (item) {
			obj[item.split('=')[0]] = item.split('=')[1]
		});

		console.log(obj);





// DOM: document object model 文档对象模型

	console.dir(document)
	// 获取页面的html
	// document.documentElement
	// 获取body
	// document.body

	// document.URL  //loacation

	// 节点 标签 元素

	// dom对象 dom元素 dom节点

	// 6种
	// 返回值是元素
	var box = document.getElementById('box');

	// 类数组 
	var pears = document.getElementsByClassName('apple');
	console.log(pears);
	// pears.style.color = 'red';

	// 类数组:  不是数组  有数组的特点(下标&长度)  不能使用数组的方法
	// for
	var a = document.getElementsByTagName('a');
	console.log(a);

	// 类数组
	// var myBox = document.getElementsByName('myBox');
	// console.log(myBox);

	// 元素
	var box1 = document.querySelector('#box');
	// 类数组
	var box2 = document.querySelectorAll('#box');
	console.log(box1)
	console.log(box2)





// 创建
	var newImg = document.createElement('img');
	newImg.src = 'resouce/22.jpg';

	// 追加:最后面的追加
	// 父元素.appendChild();
	box.appendChild(newImg);

	// 删除
	// 父元素.removeChild();
	box.removeChild(newImg);

// 正则的方法
		// test():布尔值  true false
		// exec():数组

// 字符串的方法
		// split() replace() match() search()


			子绝父相:子元素使用绝对定位 父元素设置相对定位


			position: 
				absolute:绝对定位 会脱标(浮动) 绝对定位的元素以父元素中第一个非静态定位的元素作为参考 如果没有就以浏览器作为参照
				relative: 相对定位 不脱标 以自身当前的位置作为参照  
				fixed:固定定位脱标 始终以浏览器作为参照 不跟随页面的滚动而滚动

// DOM: document object model 文档对象模型

	console.dir(document)
	// 获取页面的html
	// document.documentElement
	// 获取body
	// document.body

	// document.URL  //loacation

	// 节点 标签 元素

	// dom对象 dom元素 dom节点

	// 6种
	// 返回值是元素

// 类数组:  不是数组  有数组的特点(下标&长度)  不能使用数组的方法
	// for

// 节点属性
	// 点语法

	// 访问: 获取  设置  删除

// dom.style :行内样式 
// 计算样式 : 元素最终生效的样式
// tagName/nodeName:标签名    事件委托

// innerHTML: 所有内容 包含标签   设置时会将字符串中的标签解析出来
	// innerText:  标签中的文本  不解析字符串中的标签

// 标签中的自定义属性 无法通过点语法获取
	// console.log(box.zz);

	// 直接将index添加在dom对象上

// 通用的方法: 操作属性的方法
setAttribute//设置
getAttribute//获取
// removeAttribute();//删除

// 如果给元素的innerHTML重新赋值  该元素中的子元素绑定的所有事件和属性都会失效

// click  focus  blur mouseover(光标移入) mouseout(移除)  mouseenter(进入) mouseleave(移除) mousedown(按下) mouseup(抬起) mousemove(移动) dblclick(双击) keyup(键盘抬起) keydown(键盘按下) keypress(键盘长按) submit  reset timeupdate change input resize()

// 创建  document.createElement();

	// 追加  父元素.appendChild();

	// 删除  父元素.removeChild();
	
	// 替换  父元素.replaceChild(new, old);
// 可以使用一个已有的节点替换  影响原有的结构

// 插入  父元素.insertBefore(new, old);
// 复制: cloneNode(是否复制内容);

// 数组的常用方法
// push();//数组末尾添加 返回数组的新长度
// pop();//末尾删除 返回删除的元素
// shift();//删除第一个元素 返回删除的元素
		// unshift();//头部添加 可以一次添加多个 返回数组的新长度
sort//数组排序   如果不传参直接使用 按照ASCII表
		// reverse();//倒序
	// indexOf(元素);//根据元素查找下标  找不到-1
		// lastIndexOf();//
// join(字符);//将数组中的元素按照给定的字符拼接成字符串
// toString();//数组-->字符串
// concat();//数组的合并 
	// slice(起始下标, 结束下标);//数组的截取
// splice(起始的下标, 长度, 替换的内容);//删除 替换 插入 截取
// 遍历:// arr.forEach(function(每一个元素,对应的下标,遍历的数组){

		// });
	// ECMAScript  es
		// find();
		// findIndex();
		// map();//遍历数组
		// forEach();//遍历数组
		

		// 过滤
		// filter();//过滤
		// some();//过滤
		// every();//过滤
	// 累加
//		var arr = [12, 32, 15, 64];
//		var rel = arr.reduce(function (a, b) {
//			return a + b;
//		});
//		console.log(rel);
// 点语法
	// []

	// JSON的遍历 for-in
// json互通

	// JSON字符串 
	// JSON.parse(): jsonString-->json 只能解析标准json字符串
// eval('(jsonString)')  jsonString-->json  相对不安全  


<!-- 节点树 -->
	<!-- 树状结构:描述dom结构 -->
	<!-- 父子关系 兄弟关系 -->
// firstChild:第一个子节点 包含文本节点
	// firstElementChild:第一个元素节点 标签

// childNodes:所有子节点  文本节点 元素节点
	// children:所有子元素  元素节点

// lastChild
	// lastElementChild

// nextSibling:兄弟关系 下一个节点
	// nextElementSibling: 兄弟关系 下一个元素节点

// previousSibling;  上一个
	// previousElementSibling;

	// parentNode:获取父元素 


// 字符串: JS中的基本数据类型  '' "" ``
	// '""'  

	// 字符串是一个特殊的字符数组

// 数据类型:
		// 基本数据类型:number string boolean undefined 
		// 引用数据类型:object null function array RegExp Math Date...

// 基本数据类型:number string boolean undefined 
		// 引用数据类型:object null(空对象)

// 隐式转换
		// 任何类型和字符串做+运算  都是字符串拼接

/ 对象:Object  JS中的一种数据类型 属性和方法

	// 属性是用来描述对象的特征 方法是用来描述对象的功能

// 属性
	// 方法

	// 字符串的常用方法
	// length: 字符串的长度
	// concat();
	// 
	// indexOf(字符, 起始的位置);//根据字符找下标
	// lastIndexOf();//根据字符找下标
	// charAt();

	
	<!-- 任意多个回车 table 空格 都会以一个空格的形式在页面上显示 -->

// substring(起始的位置, 结束的下标);//截取字符串
	// slice(起始的位置, 结束的下标);//截取字符串
	// substr(起始的位置, 长度);//截取字符串

// toUpperCase();//转为大写
	// toLowerCase();//转为小写
	
	
	// trim();//去除首尾空格

// split(char);//根据给定的字符分割字符串 

// replace(被替换的内容, 新的内容)  内容替换

// 赋值运算符: = 
		// 数学运算符: +-*/ %
// 比较运算符:> < >= <= != == ===
// 逻辑运算符: && || !

		// 自增自减运算符:++ --

// 自增自减运算符配合其他运算符组合使用时 
		// 1.++/--在前, 先自增/自减再取值运算
		// 2.++/--在后, 先取值运算再自增/自减


// RegExp(规则, 修饰符);
	// i:忽略大小写
	// g:全局
	// m:多行
	// 1.使用构造函数创建
	// var r1 = new RegExp('box', 'igm');

	// 2.字面量创建
	var r2 = /box/igm;//new RegExp('box', 'igm')

	var s1 = 'this is a bOx, that is another Box';

	// 正则两个方法
	// test(); 返回值是一个布尔值  满足正则就返回true 
	// exec();
	var rel = r2.test(s1);
	console.log(rel);

	// var rel2 = r2.exec(s1);
	// console.log(rel2);

	// 字符串的方法
	// split();
	// replace();
	// match();
	// search();

/*禁止用户选中内容 需要兼容*/
			user-select: none;

/*改变鼠标的样子*/
			cursor: pointer;

/*页面上不显示 占位置 html结构有*/
			/*opacity: 0;*/
			/*visibility: hidden;*/

			/*页面上不显示 不占位置 html结构有*/
			/*display: none;*/

/*标准盒模型(box-sizing: content-box;):width&height是content的尺寸 再加padding  border 往外加
			
			怪异盒模型(box-sizing:  border-box 移动端布局)width&heght=content+padding+border
			*/

// dom.style: 行内样式  带单位字符串

// dom的属性// offsetLeft(x)/offsetTop(y): 只读属性  元素相对于浏览器可视区左上角的坐标
// clientLeft/clientTop: 边框宽度
// scrollLeft/scrollTop:元素内容滚动过的距离
// scroll: 监听元素的滚动
// 如果需要获取到页面滚动的距离 通过html标签获取
// dom.offsetWidth/Height    : content+padding+border  元素可视区的大小
// dom.clientWidth/Height   :contetn+padding
// dom.scrollWidth/Height



延迟加载/懒加载: 节省性能&网速 
		

		需要展示的时候再加载(请求数据)
	
		页面的高度+滚动过的距离 >= 元素距离顶部的y

		offsetLeft/Top:  元素距离可视区左上角的坐标
		clientLeft/Top:  边框的宽度
		scrollLeft/Top:  滚动过的距离
		offsetWidth/Height: border+padding+content
		clientWidth/Height: padding+content
		scrollWidth/Height: 元素内容可以滚动的区域  

// 用window的属性和方法时 可以省略 window.


// 下拉刷新/下拉加载/加载更多
// 1.网络请求
// 2.展示数据
// 3.修改加载更多的位置 挪到新数据的底部



					第五个月



		$('ul li:gt(2)').css('background','red')//大于
		$('ul li:lt(2)').css('background','green')//小于
		$('ul li:lt(4):gt(1)').css('background','red')
		$('ul li').slice(1,4).css('background','red')
		$('div').filter('.box').css('background','red')//筛选满足条件的
		$('div').not('.box').css('background','red')//筛选不满足条件的
		$('.box').html()不写参数 默认满足条件的第一个
		写参数 修改满足条件的全部
		原生的innerHTML相当于Jq里面的html
		原生的innertext相当于Jq里面的text
		原生转Jq  $   Jq转原生用[下标]  get[下标]
		var box=document.getElementsByClassName('box')[0];
		console.log(box)
		console.log($('.box')[0].innerHTML)
		console.log($('.box').get(0).innerHTML)
		console.log($('.box').text())
		$('.box').html('今天天气真好')

//		$('ul li:last').css('background','red');
//		$('ul li:odd').css('background','red');
//		$('ul li:even').css('background','red')
		$('ul li').filter('.box').css('background','red').end().filter('li').css('color','green');
//		$('ul li').not('.box').css('background','yellow')
//		$('div').has('span').css('background','pink')//包含子孙元素    看这个里面的子孙元素
		$('div').html('空间十分合适的空间规划是看得见').css({
			width:200,
			height:200,
			background:'red'
		}).click(function(){
			console.log($(this).html());
		})

//jq里面的循环是each跟原生的foreach参数正好相反   第1个参数代表的是下标  第2个是每一项
		$('li').each(function(index,item){
			//console.log(item)
			$(this).html(index+1)
		})
//		var arr=['red','green','pink']
//		arr.forEach(function(item,index,arr){
//			console.log(item,index,arr)
//		})
		console.log($('#h2').index());//同级下的索引下标
//		$('.box').children('h2').css('background','red');//找儿子
//		$('.box').find('h2').css('background','red');//找孙子
		console.log($('h2').eq(-1).html());//-1是最后一个 依次类推
//		$('div').next().css('background','green');
		//下一个兄弟的所有节点   可以带筛选条件
//		$('div').nextAll('p').css('background','pink')
		//上一个兄弟的所有节点   可以带筛选条件
//		$('p').prevAll('div').css('background','yellow')
		//找所有的兄弟     可以带筛选条件
		$('span').siblings('p').css('background','yellow')


var obj={
			name:'小花',
			age:18
		}
		$('#div1').data('data',obj)
		//$('#div1').removeData('data')//删除
		$('#div1').click(function(){
			console.log($(this).data('data'))
		})
		
		$('input').prop('checked',true)
		//$('input').prop('checked',false)
		console.log($('input').prop('checked'))
		
		//console.log($('input').val(789))
		console.log($('#div1').attr('id'));
//		$('#div1').attr('class','div2')
		$('#div1').prop('class','div2')
//		$('div').attr('id','div3')
//		$('#div1').attr('index','1')
		//$('#div1').prop('index','1')//不能设置自定义属性
//		$('#div1').removeAttr('class')
		$('#div1').removeProp('class')
		
		//attr可以获取  设置原有属性跟自定义属性  1个参数是获取   2个参数是设置
		//prop只能获取  设置原有属性      一般用在属性值为true跟false的属性值
		//attr和prop添加属性

$('#div1').addClass('div2');//添加class
		//$('#div1').removeClass('div2')//删除class
//		$('#div1').toggleClass('div2')//如果没有则添加    反之删除
		//$('#div1').toggleClass('div2')
		console.log($('#div1').hasClass('div2'))//看这个元素有没有这个类   如果有返回true   反之为false
		
		//通过css获取的是带单位的
		//console.log($('#box').css('width'))
		//通过css获取的是不带单位的
		//console.log($('#box').width())
		//console.log($('#box').innerWidth())//width+padding
		//console.log($('#box').outerWidth())//width+padding+border
		//console.log($('#box').outerWidth(true))//width+padding+border+margin
		//$('#box').innerWidth(300,true)
		//console.log($('#box').width())
		console.log($(window).width())//可视区的宽
		console.log($(window).height())//可视区的高
		console.log($(document).width())//文档的宽
		console.log($(document).height())//文档的高
		//当可视区宽高小于文档的宽高   显示的是文档的宽高
		//当可视区宽高大于文档的宽高   显示可视区宽高


//$('span').insertBefore($('div')).css('color','red')//插入
		//$('div').before($('span')).css('color','red')
		
		//$('<p>').prependTo($('div'))//添加到前面
		$('div').prepend($('<p>'))
		$('div').append($('<p>12333<p>'))//添加到后面
		
		//insertBefore  把元素1 插入到 2 的前面  前者是被操作的   后者是参考的元素
		//before 元素 1 的前面是元素 2
		//两者的区别是  后续操作的时候  有影响
		
		//prependTo把元素 1 添加到元素 2 的前面
		//appendTo是往后面添加
		
		//把元素添加到body里面
		//$('<div>123</div>').appendTo($('body'))//appendTo 添加到
		//body里面添加创建出来的div
		$('body').append($('<div>123</div>'))//append  添加
		
//		$('div').click(function(){
//			console.log($(this).html())
//		})
		//克隆默认不克隆事件行为     加参数true就克隆事件行为
		//$('div').clone(true).appendTo($('body'))//clone  克隆


//$('div').replaceWith($('<p>p</p>'))//用后面的元素替换前面的元素
		//$('<p>p</p>').replaceAll($('div'))//用前面的元素替换后面的元素
		//$('body').empty()
		//$('div').empty()// empty  清空标签的内容
		//$('div').html('')// ''代表清空标签的内容
//		$('div').click(function(){
//			console.log($(this).html())
//		})
//		var $div1=$('div').remove()
		//var $div1=$('div').detach()
		//console.log($div1)
		//$('body').append($div1)
		//remove()删除元素   会有一个返回值    返回值是删除那个元素    再添加  原先的事件行为不保留
		//detach() 删除元素   用法跟remove一样   区别是会保留原先的事件行为
		
		//closest  找最近的元素    如果它自身就满足条件   那么就找它自身



//scrollLeft()获取滚动的值   X轴
//		$(window).on('scroll',function(){
//			console.log($(window).scrollTop())//scrollTop()  获取滚动的值  Y轴
//			$(window).scrollTop(300)//设置
//		})
		
		//$('div:visible').css('background','red')//可见的元素
		//$('div:hidden').css('background','green')//不可见的元素
		
		//事件
//		$('#box').on('click',function(){
//			console.log($(this).html())
//		})
		//on可以绑定自定义事件    触发的时候用trigger
		//off取消事件   默认的是取消的全部事件   可以参数   具体取消哪个事件
		//one只执行一次
//		$('#box').on({
//			click:function(){
//				console.log(111)
//			},
//			mouseover:function(){
//				console.log(222)
//			}
//		})
//		$('#box').off('click')//不写参数  就是取消全部的事件
		
//		$('#box').on('abc',function(){
//			console.log(111)
//		})
//		$('#box').on('ef',function(){
//			console.log(222)
//		})
//		$('#box').on('click',function(){
//			$('#box').trigger('abc')//触发事件
//			$('#box').trigger('ef')
//		})

//		$('#box').one('click',function(){
//			console.log(111)
//		})


//		$('li').on('click',function(){
//			console.log($(this).html())
//		})
//		$('<li>444</li>').appendTo('ul')

//		$('ul').on('click','li',function(){
//			console.log($(this).html())
//		})
//		$('<li>444</li>').appendTo('ul')
		//jq父级元素.on(事件， 子元素， 函数)
		//把事件绑定在父级，但触发事件的是子级
		//事件代理
		//事件代理：利用冒泡的原理，将事件加在父级上。利用事件源，确定是谁触发这个事件
		//好处：
		//1.提高性能
		//2.新添加的元素，也有之前的事件




	$('#box').hover(function(){
			console.log(11)//划上去时执行
		},function(){
			console.log(222)//滑离时执行
		})
		
		//console.log($('#div3').offset().left)//元素到文档左边的距离
		//console.log($('#div3').offset().top)//元素到文档顶部的距离
		//元素到有定位父级的距离  如果没有定位的父级则到body   不包含margin
		//console.log($('#div3').position().left)
		//console.log($('#div3').position().top)
		//有定位的父级   如果没有定位的父级  到html
		//console.log($('#div3').offsetParent())






//显示
		$('#show').on('click',function(){
			$('#box').show(1000,function(){//第一个参数是时间   第二个参数是回调函数
 				console.log(1)
			})
		})
		//隐藏
		$('#hide').on('click',function(){
			$('#box').hide(1000,function(){
				console.log(2)
			})
		})
		//如果是显示就隐藏   反之则显示
		$('#toggle').on('click',function(){
			$('#box').toggle(1000,function(){
				console.log(3)
			})
		})
		
		$('#fadeIn').on('click',function(){//淡出
			$('#box').fadeIn(1000,function(){
				console.log(4)
			})
		})
		$('#fadeOut').on('click',function(){//淡入
			$('#box').fadeOut(1000,function(){
				console.log(5)
			})
		})
		$('#fadeTo').on('click',function(){//第二个参数是改变透明度
			$('#box').fadeTo(1000,0.5,function(){
				console.log(6)
				$(this).css('background','pink')
			})
		})
		$('#fadeToggle').on('click',function(){
			$('#box').fadeToggle(1000,function(){
				console.log(7)
			})
		})
		$('#slideUp').on('click',function(){//向上卷起
			$('#box').slideUp(1000,function(){
				console.log(11111)
			})
		})
		$('#slideDown').on('click',function(){//向下展开
			$('#box').slideDown(1000)
		})
		$('#slideToggle').on('click',function(){
			$('#box').slideToggle(1000)
		})
//		$('#yun').on('click',function(){
//			$('#box').animate({
//				width:300,
//				opacity:0.5
//			},1000,'swing',function(){
//				$('#box').animate({
//					height:300
//				})
//			})
//		})
		//animate(对象， 时间， 运(缓)动的风格， 回调函数)
		$('#yun').on('click',function(){
			$('#box').animate({
				left:300
			}).animate({
				top:300
			}).delay(1000)//延迟
			.animate({
				left:0
			}).animate({
				top:0
			})
		}



暂停
//$('#box').stop()默认只会阻止当前运动
		//$('#box').stop(true)第一个参数是true，阻止后续的运动
		//$('#box').stop(true，true)第二个参数可以立即停止到指定的目标点（仅限当前的运动）
		//$('#box').finish()立即停止到所有指定的目标点(高版本库才有)




//		var a=3
//		var b=a
//		a+=3
//		console.log(a,b)//基本数据类型的复制只是值的复制
//		var a=[1,2,3,4]
//		var b=a
//		a.push(5)
//		console.log(a,b)//引用数据类型的复制不仅是值的复制也是引用地址的传递
//		console.log($.type([]))//判断类型
//		console.log($.type({}))
//		console.log($.type(/a/))
//		console.log($.trim(' ab c d '))//去左右的空格
//		console.log($.inArray(4,[1,2,3,1]))//相当于indexOf
//		var arr=[1,2,3,4]
//		$.each(arr, function(index,item) {
//			console.log(index,item)//遍历数组
//		});
		//以上的方法是工具方法   在jq跟js里面都可以用
//		function fn(x,y){
//			console.log(this)
//			console.log(x)
//			console.log(y)
//		}
//		fn(1,2)
//		var obj={
//			name:'kl'
//		}
//		$.proxy(fn,document,30,40)()//改变this指向
//		$.proxy(fn,document,30)(40)
//		$.proxy(fn,obj)(30,40)


//		var obj={
//			a:{
//				name:'小花'
//			}
//		}
//		extend继承
//		var obj1=$.extend({},obj);//浅拷贝  会相互影响 
//		console.log(obj1)
//		obj1.a.name='小红'
//		console.log(obj.a.name)//小红
		
//		var obj1=$.extend(true,{},obj);//深拷贝 不会相互影响
//		console.log(obj1)
//		obj1.a.name='小红'
//		console.log(obj.a.name)//小花


//		$('span').wrap('<div>')//每个span都被div包裹
//		$('span').wrapAll('<div>')//一个div包裹所有的span
//		$('span').wrapInner('<a>')//span的里面是a标签   a标签里面是span的内容
//		$('span').unwrap()//删除span的父级   不能删除body的父级
//		$('span').add('div').css('background','red')//可以同时改变span和div的背景颜色


//		var obj3=$.extend({},obj,obj1,obj2)
//		console.log(obj3)//合并对象
		var obj3=Object.assign({},obj,obj1,obj2)
		console.log(obj3)


//$('div:empty').css('background','red')//筛选没有子元素或者文本的元素    它是一个选择器
		//empty()它是一个方法
		//$('div:parent').css('background','red')//筛选包含子元素或者文本的标签
		$('div:contains("111")').css('background','red')//筛选包含具体内容的元素
第六个月
sass
			依赖ruby环境
				下载：https://rubyinstaller.org/downloads/

			如何检测是否安装成功：
				在window下，按win+r，输入cmd
				在黑框中，ruby -v
					出现版本号 代表成功

			更新环境：
				window:  下载新的，删除旧的，然后替换
				mac:  ruby-china.org/wiki/rvm-guide
		
		切换源：
			1 添加、替换 (需要联网)
				gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ 
			2 查看 
				gem sources -l
		安装sass：
			gem install sass
		检测是否成功：
			sass -v

		特别注意：
			所有需要环境的东西，或者需要编译的东西，路径中都不允许有空格或中文或特殊符号。
sass: 
			版本：
				3.0 -   扩展名 .sass
					.box
						width: 100px;
						....
					...
					
				3.0 +   扩展名 .scss
					.box{
						width: 100px;
					}
			通过编译把.scss文件变成.css的文件

				Sass编译
					单文件转换命令 sass 编译的文件.scss:输出的文件.css

					


单文件监听命令 sass --watch input.scss:output.css
					如果你有很多的sass文件的目录，你也可以告诉

					sass监听整个目录： sass --watch 要监听的文件夹名称:输出到哪个文件夹中
				编译格式
					nested：嵌套缩进的css代码，它是默认值。
					expanded：没有缩进的、扩展的css代码。
					compact：简洁格式的css代码。
					compressed：压缩后的css代码。
	

			路径如何找？
				1.在文件中先找到，复制地址栏，打开cmd,输入 cd空格粘贴地址 
				2.右键管家，增加菜单->在此处打开命令窗口 点应用就可以了。
					使用的时候，直接在文件夹上单击右键，找到在此处打开命令窗口
			常用的window命令： (win/mac)
				cd 打开文件或文件夹
				cd.. 返回上一层目录
				dir/ls  查看当前目录中有哪些文件
作用域：
		全局：定义在外面的
		局部：定义在某个选择器内部的
			如果自己有就用自己的，没有往上找...
		带!default的变量
			如果外面定义了，用外面的，没定义用自己的。
	
	计算：
		+ -
要求： 运算符前后必须加空格
			支持数值、颜色运算
			#f00 -> 255 0 0  - 70
嵌套：
		标签
		属性
			复合样式（可以缩写的）：
			background
			font
			border
			margin
			padding
			transition
			animation

			不是复合样式：
			box-shadow: 多个值;
			text-shadow: 多个值;
			transform: 多个值;

	@at-root 跳出
		适合写某个块的时候
		单个 @at-root 选择器
		多个 @at-root { 选择器 }
	继承：
		可以继承某个选择器
	占位选择器：
		如果调用了，才会被编译出来。
	&  表示上一层选择器
	@mixin 混合 
	字符串插值
移动端页面头部
	meta
		viewport content可选参数 
		width C viewport宽度(数值/device-width)  
		height C viewport高度(数值/device-height) 
		initial-scale C 初始缩放比例 1 任意值 
		user-scalable C 是否允许用户缩放 yes/no 
		maximum-scale C 最大缩放比例 
		minimum-scale C 最小缩放比例
		
		<meta id="viewport" name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">

		移动端：可视区是980px
			980px > 414px (设备宽度)
320
			640
				1rem = 40px
			750
				1rem = 50
		retina屏幕及适配
			所谓"Retina"是一种显示标准，是把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。
			图片适配
				背景
					背景图片适配 
		background: url(pic.png) 0 0 no-repeat; 
		background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x); 
		必须使用-webkit-前缀
				img标签
					<img src="pic.png" srcset="pic@2x.png 2x">
rem:  W3C在文档中有这么一句话：font size of the root element
em 单位：
			其他属性的em是根据自己的font-size计算来的。
			font-size如何计算来的？
				根据父级字体大小计算来的
					如果父级都没设置，根据html文字大小来的 (16px - 网页的默认文字大小)dew
browser-sync插件
	nodeJs环境安装
		https://nodejs.org/en/
	npm
		Node Package Manager
			是node.js的模块依赖管理工具
	
	npm切换源
		查看当前源
			npm config get registry
		切换淘宝源	
			npm config set registry https://registry.npm.taobao.org

	npm 更新
		npm install -g npm 指令会自动更新至最新版
		Mac或win权限问题
			Mac sudo ...
			Win，在 搜索中找到命令窗口（cmd），然后右键，管理员身份运行
	
	browser-sync安装、测试
		安装 npm install -g browser-sync
		使用 browser-sync --version 查看版本
		如何开启： 
			browser-sync start --server --files "style/*.css, js/*.js, *.html"

			默认找index.html页面的
	gulp: 自动化构建工具
			npm 安装东西，把npm替换成cnpm
				cnpm 淘宝的镜像服务器 
					安装cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org

			gulp 安装：
				cnpm install gulp-cli -g
			gulp使用：
				1 在项目的根目录中，新建一个 gulpfile.js 的文件
				2 使用插件，
					sass编译：https://www.npmjs.com/package/gulp-sass
				3 安装依赖(在gulp中 require引入了什么，就装什么)：
					cnpm/npm i 插件名称 --save-dev
					cnpm/npm i 插件名称 CD
nodejs 环境
	
	npm 指令：
		安装：npm i xxx / npm install xxx
		删除：npm uninstall xxx
	npm：
		npm 官方源：
			npm config set registry https://registry.npmjs.org/
		淘宝镜像：
			npm config set registry https://registry.npm.taobao.org
		查看当前使用的是哪个源：
			npm config get registry
	cnpm
		npm install -g cnpm --registry=https://registry.npm.taobao.org

	安装gulp
		cnpm/npm i gulp-cli -g

	browser-sync 插件（浏览器自动刷新）
<!-- 以下是每一个项目需要做的 -->
1 打开项目的根目录
	2 gulpfile.js
	3 在gulpfile.js中require进来什么东西就需要在cmd中安装依赖
		cnpm/npm i xxxx  --D   (--save-dev)
	4 在cmd中输入gulp 任务名
lib-flexible - 淘宝
		flexible.js  核心文件
		flexible_css.js 输出css
			dpr 1  41.4
			dpr 2  82.8
	目前Flexible会将视觉稿(效果图)分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。
	同时1rem单位被认定为10a。
	假设设计稿（视觉稿）是750的可以计算出： 
		1a = 7.5px 
		1rem = 75px 
	那么我们这个示例的稿子就分成了100a，也就是整个宽度为10rem，对应的font-size为75px

	需要了解的概念
		物理像素(physical pixel) 
		物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。
		每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果

		设备独立像素(density-independent pixel) 
		设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。

		CSS像素 
		CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。
		一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。

		屏幕密度 
		屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。

		设备像素比(device pixel ratio) 
		设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。
		它的值可以按下面的公式计算得到： 
			设备像素比 ＝ 物理像素 / 设备独立像素 
		
		在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。
		而在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 
		dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。
		dip可以用来辅助区分视网膜设备还是非视网膜设备。
		综上所述，得到一个概念
			众所周知，iPhone6的设备宽度和高度为375pt * 667pt,可以理解为设备的独立像素；
	而其dpr为2，根据上面公式，我们可以很轻松得知其物理像素为750pt * 1334pt。
			在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。
	在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。
浮动所产生的问题：
			浮动的特点：脱离文档流
			父级无法适应子元素的高度
		
		什么时候需要清浮动？
			子元素浮动了，父级无法撑开（适应）高度
			除非：
				1 父级有高度（可以确定高度的时候）
				2 父级本身需要浮动的时候 (父级的父级是否需要清浮动呢？)
clear: left/right/both
		让当前元素不跟随上一个元素进行排列
clearfix
				1 可以清浮动 
					最后一个元素块元素、不跟随上一个元素排列
					after   block    clear
				2 解决子元素的margin-top会带着父级一起下来
.clearfix:after,.clearfix:before{
			content: "";
			display: table;
		}
		.clearfix:after{
			clear: both;
		}
/* background-color: pink; */
			/* BFC  块级格式化上下文 */
			overflow: hidden;
盒模型：有宽度 width height padding border margin
		  无宽度 盒模型永远保持父级的宽度如果加了padding/margin/border则会从宽度中减去相应的值，也就是说实际的宽度会减小盒模型还是保持父级的宽度

vw  viewport's width  视窗宽度
		vh  viewport's height  视窗高度
		vmin viewport's min  视窗中最小的那个(宽和高中最小的)
		vmax viewport's max  视窗中最大的那个
			100vw = 100%
			1vw = 1%
		px > vw
		640  750
			335px -> vw?
			公式：元素的尺寸 / 视觉稿的尺寸 * 100
				335 / 640 * 100
开启弹性盒子
display: flex;
/* 均分几份 */
			flex: 1;
row 水平 
row-reverse 水平反转 
column 垂直 
column-reverse 垂直反转
flex-wrap - 换行
				nowrap 不换行 
				wrap 换行(宽度不够自动换行) 
				wrap-reverse 换行并反转

				兼容：华为荣耀6p，解决办法是子元素写个inline-block。。只能是这个。
			不能是block或者inline? - 2017-1-5
flex-shrink (收缩比例)
				此时剩余空间是不足时都将等比例缩小 
				0 表示不参加收缩比例
				若没写该属性，则为1

				计算剩余空间：
					元素总宽度和 - 父级宽度 = 超出的宽度
						假设a,b,c 宽度为 100,200,150，收缩比例为 2:1:1 

					首先是每个项目的wdith值乘以flex-shrink值求积 
						100（元素宽度） * 2（收缩比例为2） = 200 
						200 * 1 = 100 
						150 * 1 = 150 

					然后再求和所有项目的乘积
						200 + 100 + 150 = 450（扩大以后的和） 

					得到求占比之后还要乘以要腾出的空间 
						200（单个元素的扩后的比例） / 450（所有的和） * 超出的宽度 = 最终收缩多少像素

					1 800
					2 200
					3 60 
					4 60
					5 60 
					-> 1180 - 1000 = 180
					1 800 * 2  1600
					2 200 * 1  200 
					3 60  * 1   60
					4 60 * 1   60
					5 60  * 1  60
					->  1980
					1600/1980*180
flex-grow (扩展比例)
				剩余空间是正值的时，伸缩项目相对于伸缩容器里其他伸缩项目能分配到空间比例 
					若没写该属性，则为0，0代表不参与扩展

			flex缩写
			flex: none | [ <‘flex-grow’> <‘flex-shrink’>? || <‘flex-basis’> ]

/* align-items: flex-end; */ 
				主轴对齐方式（水平）
				justify-content（水平对齐方式）
					flex-start 左对齐 
					flex-end 右对齐 
					center 居中对齐
					space-between 两端对齐(之间的间隔相等) 
					space-around 分散对齐
				侧轴对齐方式（垂直对齐方式）
				align-items
					flex-start 起点对齐 
					flex-end 终点对齐 
					center 中间对齐 
					baseline 基线对齐 
					stretch 默认值(未设置高度或设为auto，将占满整个容器的高度)

				align-self （允许单个项目有与其他项目不一样的对齐方式）
					auto | flex-start | flex-end | center | baseline | stretch 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 可覆盖align-items属性 默认值auto，表示继承父级元素的align-items，如果没有父级，则则等同于stretch
移动端事件：touchstart 点击
					touchmove   移动
					touchend   抬起	
			var startX = moveX = 0;

		oBanner.addEventListener('touchstart', function(e){
			startX = e.touches[0].clientX;
		}, false)
		oBanner.addEventListener('touchmove', function(e){
			moveX = e.touches[0].clientX;
		}, false)
		oBanner.addEventListener('touchend', function(e){
			if(moveX == 0) return;
			if(startX > moveX){
				num++;
			}
			if(startX < moveX){
				num--;
			}

如果图片是动态状态进来的
		需要让他创建完成以后再执行
			ready
			onload
var mySwiper = new Swiper ('.abc', {
		    // direction: 'vertical', // 垂直切换选项
		    // loop: true, // 循环模式选项
		    // initialSlide: 1,
		    // speed: 2000,
		    // 如果需要分页器
		    pagination: {
		      el: '.swiper-pagination',
		    },
		  })       